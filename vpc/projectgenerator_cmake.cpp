/**
 * 
 * Linux-only project generator for CMake files
 * 
 * This isn't intended to be used as a VPC -> cmake converted, however, this
 * is planned for the future. 
 * 
 */ 

#include "projectgenerator_linux.h"
#include "solutiongenerator_linux.h"
#include "tier1/utlstring.h"
#include "tier1/strtools.h"

static const char *g_pOption_BufferSecurityCheck = "$BufferSecurityCheck";
static const char *g_pOption_CustomBuildStepCommandLine = "$CustomBuildStep/$CommandLine";
static const char *g_pOption_PostBuildEventCommandLine = "$PostBuildEvent/$CommandLine";
static const char *g_pOption_CompileAs = "$CompileAs";
static const char *g_pOption_ConfigurationType = "$ConfigurationType";
static const char *g_pOption_Description = "$Description";
static const char *g_pOption_EntryPoint = "$EntryPoint";
static const char *g_pOption_ExtraCompilerFlags = "$GCC_ExtraCompilerFlags";
static const char *g_pOption_ExtraLinkerFlags = "$GCC_ExtraLinkerFlags";
static const char *g_pOption_CustomVersionScript = "$GCC_CustomVersionScript";
static const char *g_pOption_ForceInclude = "$ForceIncludes";
static const char *g_pOption_IgnoreAllDefaultLibraries = "$IgnoreAllDefaultLibraries";
static const char *g_pOption_LocalFrameworks = "$LocalFrameworks";
static const char *g_pOption_LowerCaseFileNames = "$LowerCaseFileNames";
static const char *g_pOption_OptimizerLevel = "$OptimizerLevel";
static const char *g_pOption_AdditionalDependencies = "$AdditionalDependencies";
static const char *g_pOption_Outputs = "$Outputs";
static const char *g_pOption_PrecompiledHeader = "$Create/UsePrecompiledHeader";
static const char *g_pOption_PrecompiledHeaderFile = "$PrecompiledHeaderFile";
static const char *g_pOption_SymbolVisibility = "$SymbolVisibility";
static const char *g_pOption_SystemFrameworks = "$SystemFrameworks";
static const char *g_pOption_SystemLibraries = "$SystemLibraries";
static const char *g_pOption_UsePCHThroughFile = "$Create/UsePCHThroughFile";
static const char *g_pOption_TargetCopies = "$TargetCopies";
static const char *g_pOption_TreatWarningsAsErrors = "$TreatWarningsAsErrors";

/* Checks the file extension if it's valid */
static bool CheckExtension(const char* file)
{
	const char* ext = V_GetFileExtension(file);

	return strcmp(ext, "cpp") == 0 || strcmp(ext, ".h") == 0 || strcmp(ext, ".cc") == 0 ||
	       strcmp(ext, "hxx") == 0 || strcmp(ext, "c") == 0 || strcmp(ext, ".m") == 0;
}

/* Stolen from the makefile generator */
static const char *UsePOSIXSlashes(const char *pStr)
{
	int len = V_strlen(pStr) + 2;
	char *str = (char *)malloc(len * sizeof(char));
	V_strncpy(str, pStr, len);
	for (int i = 0; i < len; i++)
	{
		if (str[i] == '\\')
		{
			// allow escaping of bash special characters
			if (i + 1 < len && (str[i + 1] != '"' && str[i + 1] != '$' &&
								str[i + 1] != '\'' && str[i + 1] != '\\'))
				str[i] = '/';
		}
		if (str[i] == '\0')
			break;
	}
	return str;
}

class CCMakeProjectGenerator : public CLinuxProjectGenerator
{
public:
	CCMakeProjectGenerator() noexcept;

	virtual void Write(CSpecificConfig* pRelease, CSpecificConfig* pDebug, const char* folder, CBaseProjectDataCollector* generator);
};

class CCMakeSlnGenerator : public CLinuxSolutionGenerator
{
public:
	CCMakeSlnGenerator() noexcept;

	virtual void WriteSolution(const char *pSolutionFilename, CUtlVector<CDependency_Project*> &projects);
};

static CCMakeProjectGenerator g_CMakeProjectGenerator;
static CCMakeSlnGenerator g_CMakeSlnGenerator;

/*

PROJECT GENERATOR COMPONENT

*/

CCMakeProjectGenerator::CCMakeProjectGenerator() noexcept :
	CLinuxProjectGenerator("cmake")
{

}

void CCMakeProjectGenerator::Write(CSpecificConfig* pRelease, CSpecificConfig* pDebug, const char* folder, CBaseProjectDataCollector* generator)
{
	if(!g_pVPC->m_bCMake) return;
	
	/* Create the filename... */
	char cmakelists[512];
	snprintf(cmakelists, 512, "%s/CMakeLists.txt", folder);

	/* Fix up the project name */
	char projectName[512];
	V_StripExtension(g_pVPC->GetOutputFilename(), projectName, sizeof(projectName));

	printf("CMAKE: Saving %s\n", cmakelists);

	FILE* fs = fopen(cmakelists, "w");

	if(!fs)
	{
		printf("ERROR: FAILED TO OPEN CMAKELISTS.TXT!!\n");
		abort();
	}

	fprintf(fs, "# AUTOGENERATED CMAKE FILE. NOT INTENDED FOR BUILDING.\nproject(%s C CXX)\n\n", projectName);

	/* For release */
	fprintf(fs, "if(CMAKE_BUILD_TYPE STREQUAL \"Release\")\n");
	{
		/* Includes for rel */
		CSplitString relIncludes(pRelease->m_pKV->GetString(g_pOption_AdditionalIncludeDirectories),
		                         const_cast<const char **>(g_IncludeSeparators), V_ARRAYSIZE(g_IncludeSeparators));

		fprintf(fs, "\tinclude_directories(");
		for(int i = 0; i < relIncludes.Count(); i++)
		{
			char fixedInc[512];
			V_strncpy(fixedInc, relIncludes[i], sizeof(fixedInc));
			V_FixSlashes(fixedInc);
			fprintf(fs, "%s ", fixedInc);
		}
		fprintf(fs, ")\n");

		/* Defines for rel */
		CSplitString relDefines(pRelease->m_pKV->GetString(g_pOption_PreprocessorDefinitions),
		                        const_cast<const char **>(g_IncludeSeparators), V_ARRAYSIZE(g_IncludeSeparators));

		fprintf(fs, "\tadd_definitions(");
		for(int i = 0; i < relDefines.Count(); i++)
			fprintf(fs, "-D%s ", relDefines[i]);
		fprintf(fs, ")\n");
		
		/* Extra flags for rel */
		CSplitString relFlags(pRelease->m_pKV->GetString(g_pOption_ExtraCompilerFlags),
		                      const_cast<const char **>(g_IncludeSeparators), V_ARRAYSIZE(g_IncludeSeparators));

		fprintf(fs, "\tset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ");
		for(int i = 0; i < relFlags.Count(); i++)
			fprintf(fs, "%s ", relFlags[i]);
		fprintf(fs, "\")\n\n");
		
		/* Sources */
		fprintf(fs, "\tset(SRCS \n\t\t");
		for (int i = generator->m_Files.First(); i != generator->m_Files.InvalidIndex(); i = generator->m_Files.Next(i))
		{
			/* IMPORTANT, so we don't include BS from windows */
			if(generator->m_Files[i]->IsExcludedFrom(pRelease->GetConfigName())) continue;
			if(!CheckExtension(generator->m_Files[i]->m_Filename)) continue;

			char filename[1024];
			strncpy(filename, generator->m_Files[i]->m_Filename, sizeof(filename));
			const char* filename_fixed = UsePOSIXSlashes(filename);

			fprintf(fs, "\"%s\"\n\t\t", filename_fixed);
		}
		fprintf(fs, ")\n");
	}
	/* For debug */
	fprintf(fs, "else()\n");
	{
		/* Includes for rel */
		CSplitString relIncludes(pDebug->m_pKV->GetString(g_pOption_AdditionalIncludeDirectories),
		                         const_cast<const char **>(g_IncludeSeparators), V_ARRAYSIZE(g_IncludeSeparators));

		fprintf(fs, "\tinclude_directories(");
		for(int i = 0; i < relIncludes.Count(); i++)
		{
			char fixedInc[512];
			V_strncpy(fixedInc, relIncludes[i], sizeof(fixedInc));
			V_FixSlashes(fixedInc);
			fprintf(fs, "%s ", fixedInc);
		}
		fprintf(fs, ")\n");

		/* Defines for rel */
		CSplitString relDefines(pDebug->m_pKV->GetString(g_pOption_PreprocessorDefinitions),
		                        const_cast<const char **>(g_IncludeSeparators), V_ARRAYSIZE(g_IncludeSeparators));

		fprintf(fs, "\tadd_definitions(");
		for(int i = 0; i < relDefines.Count(); i++)
			fprintf(fs, "-D%s ", relDefines[i]);
		fprintf(fs, ")\n");
		
		/* Extra flags for rel */
		CSplitString relFlags(pDebug->m_pKV->GetString(g_pOption_ExtraCompilerFlags),
		                      const_cast<const char **>(g_IncludeSeparators), V_ARRAYSIZE(g_IncludeSeparators));

		fprintf(fs, "\tset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ");
		for(int i = 0; i < relFlags.Count(); i++)
			fprintf(fs, "%s ", relFlags[i]);
		fprintf(fs, "\")\n\n");
				
		/* Sources */
		fprintf(fs, "\tset(SRCS \n\t\t");
		for (int i = generator->m_Files.First(); i != generator->m_Files.InvalidIndex(); i = generator->m_Files.Next(i))
		{
			/* IMPORTANT, so we don't include BS from windows */
			if(generator->m_Files[i]->IsExcludedFrom(pDebug->GetConfigName())) continue;
			if(!CheckExtension(generator->m_Files[i]->m_Filename)) continue;

			char filename[1024];
			strncpy(filename, generator->m_Files[i]->m_Filename, sizeof(filename));
			const char* filename_fixed = UsePOSIXSlashes(filename);

			fprintf(fs, "\"%s\"\n\t\t", filename_fixed);
		}
		fprintf(fs, ")\n");
	}

	fprintf(fs, "endif(CMAKE_BUILD_TYPE STREQUAL \"Release\")\n\n");
	fprintf(fs, "add_library(%s SHARED ${SRCS})\n", projectName);
	
	fflush(fs);
	fclose(fs);
}

/*

SOLUTION GENERATOR COMPONENT

*/


CCMakeSlnGenerator::CCMakeSlnGenerator() noexcept :
	CLinuxSolutionGenerator("cmake")
{

}

void CCMakeSlnGenerator::WriteSolution(const char* pSolutionFilename, CUtlVector<CDependency_Project*>& projects)
{
	if(!g_pVPC->m_bCMake) return;
	/**
	 * Here we will just write the master CMakeLists.txt, which will do two things: contain the base defines found in the makefile_base_posix.mak
	 * and, use add_subdirectory to add all projects
	 */ 
	printf("CMAKE: Saving master CMakeLists.txt\n");

	char dir[512];
	V_strncpy(dir, pSolutionFilename, sizeof(dir));
	V_StripFilename(dir);
	char cmakefile[512];
	V_snprintf(cmakefile, sizeof(cmakefile), "%s/CMakeLists.txt", dir);

	FILE* fs = fopen(cmakefile, "w");

	if(!fs)
	{
		printf("ERROR: FAILED TO OPEN CMAKELISTS.TXT!!\n");
		abort();
	}

	fprintf(fs, "#\n# AUTOGENERATED CMAKE FILE. DO NOT EDIT THIS OR BUILD THE SOURCE CODE WITH THIS!\n#\n");
	fprintf(fs, "\ncmake_minimum_required(VERSION 3.2)\n\nproject(SourceEngine C CXX)\n\n"); /* Required to get cmake to shut up */

	/* All the base defines in makefile_base_posix.mak. */
	fprintf(fs, "add_definitions(-DVPROF_LEVEL=1 -DGNUC)\n");

	/* Loop through all the projects and add them */
	for(int i = 0; i < projects.Count(); i++)
	{
		auto project = projects[i];
		/* Strip off the file extension to get the directory name */
		char dirname[512];
		strncpy(dirname, project->m_ProjectFilename.String(), sizeof(dirname));
		V_StripFilename(dirname);
		fprintf(fs, "add_subdirectory(%s)\n", dirname);
	}

	fflush(fs);
	fclose(fs);

}

